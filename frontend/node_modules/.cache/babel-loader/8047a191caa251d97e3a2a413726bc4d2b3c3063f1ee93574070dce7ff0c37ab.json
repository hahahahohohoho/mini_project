{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nconst LineComponent = ({\n  map,\n  lineData\n}) => {\n  _s();\n  const polylineRef = useRef([]); // 각 폴리라인을 참조하기 위한 useRef 훅\n  const {\n    naver\n  } = window; // 네이버 지도 API 객체를 window에서 가져옴\n\n  // grade에 따른 색상 딕셔너리\n  const gradeColors = {\n    1: '#FF0000',\n    // 빨간색\n    2: '#FF7F00',\n    // 주황색\n    3: '#FFFF00',\n    // 노란색\n    4: '#00FF00',\n    // 녹색\n    5: '#0000FF' // 파란색\n  };\n  useEffect(() => {\n    const convertLineData = async () => {\n      if (map && lineData && Array.isArray(lineData)) {\n        // lineData가 배열인지 확인\n\n        // 기존 폴리라인 제거 (필요할 경우)\n        polylineRef.current.forEach(polyline => polyline.setMap(null)); // 기존 폴리라인을 지도에서 제거\n        polylineRef.current = []; // 참조 배열 초기화\n\n        for (const line of lineData) {\n          const {\n            geometry,\n            grade\n          } = line; // geometry와 grade를 추출\n\n          const strokeColor = gradeColors[grade] || '#000000'; // grade에 따른 색상 설정\n\n          // LINESTRING 데이터를 파싱하여 LatLng 배열로 변환\n          const coordinates = geometry.replace('LINESTRING (', '') // 'LINESTRING (' 부분 제거\n          .replace(')', '') // ')' 부분 제거\n          .split(', ') // ', '로 좌표 구분\n          .map(coord => {\n            const [X, Y] = coord.split(' ').map(parseFloat); // 좌표 문자열을 숫자로 변환\n            return [Y, X]; // 좌표 배열 반환 (위도(Y), 경도(X) 순서로)\n          }).filter(coord => !isNaN(coord[0]) && !isNaN(coord[1])); // 유효한 좌표만 필터링\n\n          if (coordinates.length === 0) {\n            console.error(\"All coordinates are invalid or conversion failed.\"); // 모든 좌표가 유효하지 않으면 오류 로그 출력\n            continue; // 다음 라인으로 이동\n          }\n\n          // Polyline 생성\n          const polyline = new naver.maps.Polyline({\n            map: map,\n            path: coordinates.map(coord => new naver.maps.LatLng(coord[0], coord[1])),\n            // 위도(Y), 경도(X) 순서로 LatLng 객체 생성\n            strokeColor: strokeColor,\n            strokeWeight: 3,\n            strokeOpacity: 1,\n            strokeStyle: 'solid'\n          });\n          polylineRef.current.push(polyline); // 생성된 폴리라인을 참조 배열에 추가\n        }\n      } else {\n        console.error(\"Map or lineData is not defined.\"); // 맵이나 라인 데이터가 정의되지 않았을 때 오류 로그 출력\n      }\n    };\n    convertLineData(); // 비동기 함수 호출\n  }, [map, lineData, naver]); // map과 lineData가 변경될 때만 이 useEffect 훅이 실행됨\n\n  return null; // 이 컴포넌트는 UI를 렌더링하지 않으므로 null 반환\n};\n_s(LineComponent, \"6/G7kVIdrdD4l1la+q3EMoishY8=\");\n_c = LineComponent;\nexport default LineComponent;\nvar _c;\n$RefreshReg$(_c, \"LineComponent\");","map":{"version":3,"names":["React","useEffect","useRef","LineComponent","map","lineData","_s","polylineRef","naver","window","gradeColors","convertLineData","Array","isArray","current","forEach","polyline","setMap","line","geometry","grade","strokeColor","coordinates","replace","split","coord","X","Y","parseFloat","filter","isNaN","length","console","error","maps","Polyline","path","LatLng","strokeWeight","strokeOpacity","strokeStyle","push","_c","$RefreshReg$"],"sources":["C:/LEECHANGSU_MAIN/mini_project/frontend/src/components/map/LineComponent.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\n\r\nconst LineComponent = ({ map, lineData }) => {\r\n  const polylineRef = useRef([]); // 각 폴리라인을 참조하기 위한 useRef 훅\r\n  const { naver } = window; // 네이버 지도 API 객체를 window에서 가져옴\r\n\r\n  // grade에 따른 색상 딕셔너리\r\n  const gradeColors = {\r\n    1: '#FF0000', // 빨간색\r\n    2: '#FF7F00', // 주황색\r\n    3: '#FFFF00', // 노란색\r\n    4: '#00FF00', // 녹색\r\n    5: '#0000FF', // 파란색\r\n  };\r\n\r\n  useEffect(() => {\r\n    const convertLineData = async () => {\r\n      if (map && lineData && Array.isArray(lineData)) { // lineData가 배열인지 확인\r\n\r\n        // 기존 폴리라인 제거 (필요할 경우)\r\n        polylineRef.current.forEach(polyline => polyline.setMap(null)); // 기존 폴리라인을 지도에서 제거\r\n        polylineRef.current = []; // 참조 배열 초기화\r\n\r\n        for (const line of lineData) {\r\n          const { geometry, grade } = line; // geometry와 grade를 추출\r\n\r\n          const strokeColor = gradeColors[grade] || '#000000'; // grade에 따른 색상 설정\r\n\r\n          // LINESTRING 데이터를 파싱하여 LatLng 배열로 변환\r\n          const coordinates = geometry\r\n            .replace('LINESTRING (', '') // 'LINESTRING (' 부분 제거\r\n            .replace(')', '') // ')' 부분 제거\r\n            .split(', ') // ', '로 좌표 구분\r\n            .map(coord => {\r\n              const [X, Y] = coord.split(' ').map(parseFloat); // 좌표 문자열을 숫자로 변환\r\n              return [Y, X]; // 좌표 배열 반환 (위도(Y), 경도(X) 순서로)\r\n            })\r\n            .filter(coord => !isNaN(coord[0]) && !isNaN(coord[1])); // 유효한 좌표만 필터링\r\n\r\n          if (coordinates.length === 0) {\r\n            console.error(\"All coordinates are invalid or conversion failed.\"); // 모든 좌표가 유효하지 않으면 오류 로그 출력\r\n            continue; // 다음 라인으로 이동\r\n          }\r\n\r\n          // Polyline 생성\r\n          const polyline = new naver.maps.Polyline({\r\n            map: map,\r\n            path: coordinates.map(coord => new naver.maps.LatLng(coord[0], coord[1])), // 위도(Y), 경도(X) 순서로 LatLng 객체 생성\r\n            strokeColor: strokeColor,\r\n            strokeWeight: 3,\r\n            strokeOpacity: 1,\r\n            strokeStyle: 'solid'\r\n          });\r\n\r\n          polylineRef.current.push(polyline); // 생성된 폴리라인을 참조 배열에 추가\r\n        }\r\n\r\n      } else {\r\n        console.error(\"Map or lineData is not defined.\"); // 맵이나 라인 데이터가 정의되지 않았을 때 오류 로그 출력\r\n      }\r\n    };\r\n\r\n    convertLineData(); // 비동기 함수 호출\r\n  }, [map, lineData, naver]); // map과 lineData가 변경될 때만 이 useEffect 훅이 실행됨\r\n\r\n  return null; // 이 컴포넌트는 UI를 렌더링하지 않으므로 null 반환\r\n};\r\n\r\nexport default LineComponent;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}